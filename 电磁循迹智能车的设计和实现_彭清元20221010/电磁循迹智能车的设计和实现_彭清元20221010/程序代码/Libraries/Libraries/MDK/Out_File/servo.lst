C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE servo
OBJECT MODULE PLACED IN .\Out_File\servo.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE servo.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\..\Libraries\lib
                    -raries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src) DEBUG PRI
                    -NT(.\Out_File\servo.lst) TABS(2) OBJECT(.\Out_File\servo.obj) 

stmt  level    source

    1          //#include "headfile.h"
    2          //#include "servo.h"
    3          //#include "math.h"
    4          //#include "stdlib.h"
    5          
    6          
    7          //double place = 0;
    8          //double cha1;
    9          //double he1;
   10          //double cha2;
   11          //double he2;
   12          //double p;
   13          //double i;
   14          //double d;
   15          //double s_error;
   16          //int duty_ = 670;
   17          //int mid = 670; //650 730
   18          //int left = 760;   
   19          //int right = 585;
   20          //int n_s = 0;
   21          //double s_last_error;
   22          //double tuo;
   23          //double tuo_l = 0;
   24          
   25          //double cha_s;
   26          //double he_s;
   27          //double error_s;
   28          //double place_s;
   29          //double ps;
   30          //double is;
   31          //double ds;
   32          
   33          //double s_a;
   34          //double s_b;
   35          //double s_c;
   36          //int out = 0;
   37          //int compensate = 0; // 补偿
   38          //int Magnetic = 270; // 磁场强度
   39          
   40          //double smooth[20] = { 0 }; // 读取10 个 终端中的 误差 作为 偏差
   41          //double last_dy;
   42          //void my_dead()
   43          //{
   44          
   45          //}
   46          
   47          //void cal_compensate()
   48          //{
   49          //  int sum_ad = ad[4] + ad[5] + ad[9];
   50          //  
   51          //  if(sum_ad  < Magnetic)
   52          //  {
   53          //    compensate = (Magnetic - sum_ad) * 0.5;
   54          //  }
   55          //  
   56          //  else 
   57          //  {
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 2   

   58          //    compensate = 0;
   59          //  }
   60          //  
   61          //  if(compensate > 20)
   62          //  {
   63          //    compensate = 20;
   64          //  }
   65          //  
   66          //  else 
   67          //  {
   68          //    compensate = compensate;
   69          //  }
   70          //}
   71          
   72          //void Servoinit()
   73          //{
   74          
   75          //  if(out == 0)
   76          //  {
   77          //    duty_ = 580;
   78          //  }
   79          //  if(open == 0 && out == 0)
   80          //  {
   81          //     open = 1;
   82          //     sum_angle = 0;
   83          //  }
   84          //  
   85          //  if((( ((ad[0] > 70 && ad[1] > 70 )|| (ad[0] + ad[1] > 140)) && (ad[7] + ad[8]) < 50) || (abs(sum_angle
             -)>60 )) && !out)
   86          //  {
   87          //    out = 1;
   88          //    open = 0;
   89          //    sum_angle = 0;
   90          //  }
   91          
   92          //  
   93          //  if (soon_leave == 1)
   94          //  {
   95          //    duty_ = 745;
   96          //  }
   97          //  
   98          //  // 判断圆环第一个标志点 矫正姿态
   99          //  if(enter_Left == 1 && iscir == 0)
  100          //  {
  101          //    if(duty_ <= mid) duty_ += 4;
  102          //    else duty_ -= 4;
  103          //  }
  104          //  
  105          //  pwm_duty(PWMB_CH1_P74, duty_);
  106          //}
  107          
  108          
  109          //int PID_servo(){
  110          
  111          ////      在圆环里
  112          
  113          //      if(s_flag3)  //在三岔内部
  114          //      {
  115          //        
  116          //        if(in_forks_left == 1)  //在三岔左边
  117          //        {
  118          //          
  119          //          temp_ad[4] = ad[4];  // 对 ad 进行处理
  120          //          temp_ad[5] = ad[5];  // 对 ad 进行处理
  121          //          if(ad[4] < 15 && ad[5] < 15)
  122          //          {
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 3   

  123          //            
  124          //            // 引入 temp_ad 防止误判出三叉
  125          //            temp_ad[4] = ad[4] * 0.8 +  ad[0] * 0.5;
  126          //            temp_ad[5] = ad[5] * 0.8 +  ad[1] * 0.5;
  127          //          }
  128          //          
  129          //          if(abs(sqrt(ad[7]) - sqrt(ad[8])) > abs(sqrt(ad[2]) - sqrt(ad[3])))
  130          //          {
  131          //            cha2 = sqrt(ad[7]) - sqrt(ad[8]);
  132          //          }
  133          //          
  134          //          else 
  135          //          {
  136          //            cha2 = sqrt(ad[2]) - sqrt(ad[3]);
  137          //          }
  138          //          
  139          //          cha1 = ( sqrt(temp_ad[4])  - sqrt(temp_ad[5]) ) ; //水平电感差
  140          
  141          ////        cha2 = (sqrt(ad[7]) - sqrt(ad[8])) ; // 竖直电感差
  142          //          
  143          
  144          //          he1 =  (temp_ad[4] + temp_ad[5]); // 水平电感和
  145          //          
  146          //        }
  147          //        
  148          //        if(in_forks_right == 1) //在三岔右边
  149          //        {
  150          //          
  151          //          temp_ad[4] = ad[4];  // 对 ad 进行处理
  152          //          temp_ad[5] = ad[5];  // 对 ad 进行处理
  153          //          
  154          //          if(ad[4] < 15 && ad[5] < 15)
  155          //          {
  156          //            temp_ad[4] = ad[4] * 0.7 +  ad[0] * 0.5;
  157          //            temp_ad[5] = ad[5] * 0.7 +  ad[1] * 0.5;
  158          //          }
  159          //          
  160          //          cha1 =   sqrt(temp_ad[4]) - sqrt(temp_ad[5]) ; //水平电感差
  161          //          
  162          //          cha2 =  sqrt(ad[7]) - sqrt(ad[8]); // 竖直电感差
  163          //          
  164          //          he1 =  (temp_ad[4] + temp_ad[5]); // 水平电感和
  165          //        
  166          //        }
  167          //  
  168          //      }
  169          //      
  170          //      else 
  171          //      {
  172          //      
  173          //        if(normal_left == 1)
  174          //        {
  175          //            
  176          //          cha1 = ( (ad[4]) - (ad[5]) ) ; //水平电感差
  177          //    
  178          //          he1 =   (ad[4] + ad[5]) ; // 水平电感和
  179          //    
  180          //          cha2 =  ((ad[7]) - (ad[8])); //竖直电感差
  181          //        }
  182          
  183          //        else
  184          //        {
  185          //        
  186          //          if(cir_sancha == 1)
  187          //          {
  188          //            
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 4   

  189          //          if(ad[4] < 15 && ad[5] < 15)
  190          //          {
  191          //            ad[4] = ad[4] * 0.3 +  ad[0] * 0.7;
  192          //            ad[5] = ad[5] * 0.3 +  ad[1] * 0.7;
  193          //            cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  194          //          }
  195          //          
  196          //          else if(ad[4] < 35 && ad[5] < 35)
  197          //          {
  198          //            ad[4] = ad[4] * 0.5 +  ad[0] * 0.5;
  199          //            ad[5] = ad[5] * 0.5 +  ad[1] * 0.5;
  200          //            cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  201          //          }
  202          //          
  203          //          else
  204          //          {
  205          //          
  206          //            if(((ad[4] - ad[5]) > 20 && (ad[7] - ad[8]) > 10) || ((ad[4] - ad[5]) < -20 && (ad[7] - ad[8]) < 
             --10) )
  207          //            {
  208          //                if(abs(sqrt(ad[7]) - sqrt(ad[8])) > abs(sqrt(ad[2]) - sqrt(ad[3])))
  209          //                {
  210          //                    cha2 = sqrt(ad[7]) - sqrt(ad[8]);
  211          //                }
  212          //                
  213          //                else 
  214          //                {
  215          //                    cha2 = sqrt(ad[2]) - sqrt(ad[3]);
  216          //                }
  217          //           }
  218          //           
  219          //            else 
  220          //            {
  221          //               cha2 = 0;
  222          //            }
  223          //  
  224          //          }
  225          //            cha1 = sqrt(ad[4] + 0.3 * ad[0] + ad[9]) - sqrt(ad[5]  + 0.3 * ad[1] + ad[9]) ; //水平电感差
  226          
  227          //            he1 =  ad[4] + ad[5] + ad[9]; // 水平电感和
  228          //          }
  229          //          
  230          //          else 
  231          //          {
  232          //            if(ad[4] < 15 && ad[5] < 15)
  233          //            {
  234          //              temp_ad[4] = ad[4] +  ad[0];
  235          //              temp_ad[5] = ad[5] +  ad[1];
  236          //              
  237          ////              cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  238          //            }
  239          //            
  240          //            else if(ad[4] < 35 && ad[5] < 35)
  241          //            {
  242          //              temp_ad[4] = ad[4] +  ad[0] * 0.5;
  243          //              temp_ad[5] = ad[5] +  ad[1] * 0.5;
  244          //              
  245          ////              cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  246          //            }
  247          //            else 
  248          //            {
  249          //            
  250          //              temp_ad[4] = ad[4];
  251          //              temp_ad[5] = ad[5];
  252          //              
  253          ////              cha2  = sqrt(ad[7]) - sqrt(ad[8]);
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 5   

  254          //            }
  255          //              
  256          //              cha1 = sqrt(temp_ad[4]) - sqrt(temp_ad[5]);   
  257          //              
  258          //              // 修改和
  259          
  260          //              he1 =  (temp_ad[4] + temp_ad[5] + ad[9] ) + 0.001 * fabs(ad[7] - ad[8]); // 水平电感和
  261          //              
  262          //              if( (sqrt(ad[7]) - sqrt(ad[8])) > (sqrt(ad[4]) - sqrt(ad[5])) )
  263          //              
  264          //              cha2 = sqrt(ad[7]) - sqrt(ad[8]);
  265          //              
  266          //              else cha2 = sqrt(ad[4]) - sqrt(ad[5]);
  267          //            
  268          //            }
  269          //      }
  270          //    }
  271          
  272          //      s_a = 1;     //水平电感比例
  273          
  274          //      if( my_abs(cha2) > 50  )
  275          //      {
  276          //        s_b = 0.45;
  277          //      }
  278          //      
  279          //      if( my_abs(cha2) > 30 )
  280          //      {
  281          //        s_b = 0.35;
  282          //      }
  283          //      
  284          //      else 
  285          //      {
  286          //        s_b = 0.25;  //竖直电感比例
  287          //      }
  288          //      
  289          //      if(in_left) s_b = 0.8; // 左边三岔内
  290          //      
  291          //      s_c = 0.1;  //竖直电感和的比例
  292          //      
  293          //      if(cha2 == 0)
  294          //      {
  295          //         s_error  = 10000 * ( 1 * cha1 + 0.17 * cha2 ) / ( he1);
  296          //      }
  297          //      
  298          //      else 
  299          //      {
  300          //          if(cir_sancha == 1)
  301          //          {
  302          //            s_error = 8000 * ( 1.25 * cha1 + 0.15 * cha2 ) / ( he1 + my_abs(ad[7] - ad[8]));
  303          //          }
  304          //          
  305          //          else s_error  = 8500 * ( 0.83 * cha1 + 0.165 * cha2 ) / ( he1);
  306          //      } 
  307          //  
  308          //      tuo = w_angle * 0.6 + 0.4 * tuo_l; //一阶惯性滤波
  309          //      
  310          //      if(tuo > 100)
  311          //      {
  312          //        tuo = 100;
  313          //      }
  314          //      
  315          //      if(tuo < -100)
  316          //      {
  317          //        tuo = -100;
  318          //      }
  319          //  
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 6   

  320          //      if(!s_flag3 )  // 在正常轨道上循迹  
  321          //      {
  322          //          // 修改
  323          //          if(s_error > 500) s_error = 500;
  324          //          
  325          //          else if(s_error < - 500) s_error = -500;
  326          //          
  327          //          else 
  328          //          {
  329          //            s_error = s_error;
  330          //          }
  331          //          
  332          //          if(cir_sancha == 1)
  333          //          {
  334          //            
  335          //            p = 0.11 + log10(abs(s_error) + 1) * 0.028;
  336          
  337          //            d = 0.1 + 1 / ( sqrt(abs(s_error) * 2 ) + 1000);
  338          //          }
  339          //          else 
  340          //          {
  341          //          
  342          ////            p = s_error * s_error * 0.000002 + 0.11; 76 挺好
  343          
  344          
  345          //            // 摆出去 加常数
  346          
  347          //            p = s_error * s_error / 588235 + 0.127;
  348          //            
  349          //            if( p >= 0.45)
  350          //            {
  351          //              p = 0.45;
  352          //            }
  353          
  354          ////            d = 0.2; // 76 挺好
  355          
  356          //              d = 0.22;
  357          //          }
  358          //      }
  359          //      
  360          //      if(s_flag3)  //在三岔内部
  361          //      {
  362          //        
  363          //        if(in_forks_left == 1)  //在三岔左边
  364          //        {
  365          //          
  366          //          tuo = w_angle;  
  367          
  368          //          p = 0.12;
  369          //          
  370          //          d = 0.19;
  371          //          
  372          //          s_error = 8000 * ( ( cha1 * 0.85 + 0.35 * cha2  ) + s_b * cha2 ) / ( he1 + s_c * my_abs(cha2));
  373          //          
  374          //        }
  375          //        
  376          //        if(in_forks_right == 1)
  377          //        {
  378          //        
  379          //          tuo = w_angle;
  380          
  381          //          p = 0.15;
  382          //          
  383          //          d = 0.19;
  384          //          
  385          //          s_error = 8000 * ( ( cha1 * 0.8 + 0.35 * cha2  ) + s_b * cha2 ) / ( he1 + s_c * my_abs(cha2));
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 7   

  386          //          
  387          //        }
  388          //        
  389          //      }
  390          //      
  391          ////    在圆环中
  392          //      if(normal_left == 1)
  393          //      { 
  394          //          p = 0.125;
  395          //          d = 0.11;
  396          //          
  397          //          cha1 = sqrt(ad[4] + ad[0] * 0.5) - sqrt(ad[5] + 0.5 * ad[1]);
  398          //          
  399          //          cha2 = (sqrt(ad[7]) - sqrt(ad[8]));
  400          //          
  401          //          he1 = (ad[4] + ad[5]);
  402          //          
  403          //          s_error = 8000 * ( cha1 +  cha2 ) / ( he1);
  404          //      }
  405          //  
  406          //      place = p * s_error -  d * (tuo);  //进行pid 转向
  407          //    
  408          //      s_last_error = s_error;
  409          //      
  410          //      if(normal_left == 1)
  411          //      {
  412          //          if(place < (right - mid))
  413          //          {
  414          //              place = right - mid;
  415          //          }
  416          //          if(place > (left + 10 - mid))
  417          //          {
  418          //              place = left + 10 - mid;
  419          //          }
  420          //      }
  421          //      
  422          //      else 
  423          //      {
  424          //        
  425          //        if(place < (right - mid))
  426          //        {
  427          //            place = right - mid;
  428          //        }
  429          //        if(place > (left - mid))
  430          //        {
  431          //            place = left - mid;
  432          //        }
  433          //      
  434          //      }
  435          
  436          //      place = (place + mid);
  437          //      
  438          //      tuo_l = tuo;
  439          //      
  440          //      return (int)place;
  441          
  442          //}
  443          
  444          //int circle_pid_Right()
  445          //{
  446          //      ps = 2.1;
  447          //  
  448          //      ds = 0.265;
  449          //      
  450          //      cha_s = ad[0] - ( ad[1] * 0.1 + 0.9 * ad[2] );
  451          //      
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 8   

  452          //      he_s = ad[0] + ad[1];
  453          //      
  454          //      error_s = cha_s * 100  / he_s;
  455          //      
  456          //      place_s = ps * error_s -  ds * (tuo);
  457          
  458          //      if(place_s > (right - mid))
  459          //      {
  460          //          place_s = right - mid;
  461          //      }
  462          //      if(place_s < (left - mid))
  463          //      {
  464          //          place_s = left - mid;
  465          //      }
  466          
  467          //      place_s = (place_s + mid);
  468          //      
  469          //      if(place_s > 690 )
  470          //      {
  471          //        place_s = 690;
  472          //      }
  473          
  474          //      return (int)place_s;
  475          //}
  476          
  477          //int circle_pid_Left()
  478          //{
  479          //      ps = 1.2;
  480          //  
  481          //      ds = 0.265;
  482          //  
  483          //    // 利用 竖直 电感 引入 圆环
  484          //      
  485          //      error_s = 100 * ( 1.5 * (ad[4] - ad[5]) + 0.5 * ( ad[2] - ad[3]) ) / ( ( ad[4] + ad[5] ) + my_abs( a
             -d[2] - ad[3])); 
  486          //      
  487          //      place_s = ps * error_s -  ds * (tuo);
  488          
  489          //      if(place_s > (right - mid))
  490          //      {
  491          //          place_s = right - mid;
  492          //      }
  493          //      if(place_s < (left - mid))
  494          //      {
  495          //          place_s = left - mid;
  496          //      }
  497          
  498          //      place_s = (place_s + mid);
  499          //          
  500          //          if( place_s < 710 )
  501          //          {
  502          //            place_s = 710;
  503          //          }
  504          
  505          //      return (int)place_s;
  506          
  507          //       
  508          //}
  509          
  510          
  511          #include "headfile.h"
  512          #include "servo.h"
  513          #include "math.h"
  514          #include "stdlib.h"
  515          
  516          
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 9   

  517          double place = 0;
  518          double cha1;
  519          double he1;
  520          double cha2;
  521          double he2;
  522          double p;
  523          double i;
  524          double d;
  525          double s_error;
  526          int duty_ = 670;
  527          int mid = 670; //650 730
  528          int left = 760;   
  529          int right = 585;
  530          int n_s = 0;
  531          double s_last_error;
  532          double tuo;
  533          double tuo_l = 0;
  534          
  535          double cha_s;
  536          double he_s;
  537          double error_s;
  538          double place_s;
  539          double ps;
  540          double is;
  541          double ds;
  542          
  543          double s_a;
  544          double s_b;
  545          double s_c;
  546          int out = 0;
  547          int compensate = 0; // 补偿
  548          int Magnetic = 270; // 磁场强度
  549          
  550          double smooth[20] = { 0 }; // 读取10 个 终端中的 误差 作为 偏差
  551          double last_dy;
  552          void my_dead()
  553          {
  554   1      
  555   1      }
  556          
  557          void cal_compensate()
  558          {
  559   1        int sum_ad = ad[4] + ad[5] + ad[9];
  560   1        
  561   1        if(sum_ad  < Magnetic)
  562   1        {
  563   2          compensate = (Magnetic - sum_ad) * 0.5;
  564   2        }
  565   1        
  566   1        else 
  567   1        {
  568   2          compensate = 0;
  569   2        }
  570   1        
  571   1        if(compensate > 20)
  572   1        {
  573   2          compensate = 20;
  574   2        }
  575   1        
  576   1        else 
  577   1        {
  578   2          compensate = compensate;
*** WARNING C138 IN LINE 578 OF servo.c: expression with possibly no effect
  579   2        }
  580   1      }
  581          
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 10  

  582          void Servoinit()
  583          {
  584   1      
  585   1        if(out == 0)
  586   1        {
  587   2          duty_ = 580;
  588   2        }
  589   1        if(open == 0 && out == 0)
  590   1        {
  591   2           open = 1;
  592   2           sum_angle = 0;
  593   2        }
  594   1        
  595   1        if((( ((ad[0] > 70 && ad[1] > 70 )|| (ad[0] + ad[1] > 140)) && (ad[7] + ad[8]) < 50) || (abs(sum_angle)>
             -60 )) && !out)
  596   1        {
  597   2          out = 1;
  598   2          open = 0;
  599   2          sum_angle = 0;
  600   2        }
  601   1      
  602   1        
  603   1        if (soon_leave == 1)
  604   1        {
  605   2          duty_ = 752;
  606   2        }
  607   1        
  608   1        // 判断圆环第一个标志点 矫正姿态
  609   1        if(enter_Left == 1 && iscir == 0)
  610   1        {
  611   2          if(duty_ <= mid) duty_ += 4;
  612   2          else duty_ -= 4;
  613   2        }
  614   1        
  615   1        pwm_duty(PWMB_CH1_P74, duty_);
  616   1      }
  617          
  618          
  619          int PID_servo(){
  620   1      
  621   1      //      在圆环里
  622   1      
  623   1            if(s_flag3)  //在三岔内部
  624   1            {
  625   2              
  626   2              if(in_forks_left == 1)  //在三岔左边
  627   2              {
  628   3                
  629   3                temp_ad[4] = ad[4];  // 对 ad 进行处理
  630   3                temp_ad[5] = ad[5];  // 对 ad 进行处理
  631   3                if(ad[4] < 15 && ad[5] < 15)
  632   3                {
  633   4                  
  634   4                  // 引入 temp_ad 防止误判出三叉
  635   4                  temp_ad[4] = ad[4] * 0.8 +  ad[0] * 0.5;
  636   4                  temp_ad[5] = ad[5] * 0.8 +  ad[1] * 0.5;
  637   4                }
  638   3                
  639   3                if(abs(sqrt(ad[7]) - sqrt(ad[8])) > abs(sqrt(ad[2]) - sqrt(ad[3])))
  640   3                {
  641   4                  cha2 = sqrt(ad[7]) - sqrt(ad[8]);
  642   4                }
  643   3                
  644   3                else 
  645   3                {
  646   4                  cha2 = sqrt(ad[2]) - sqrt(ad[3]);
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 11  

  647   4                }
  648   3                
  649   3                cha1 = ( sqrt(temp_ad[4])  - sqrt(temp_ad[5]) ) ; //水平电感差
  650   3      
  651   3      //        cha2 = (sqrt(ad[7]) - sqrt(ad[8])) ; // 竖直电感差
  652   3                
  653   3      
  654   3                he1 =  (temp_ad[4] + temp_ad[5]); // 水平电感和
  655   3                
  656   3              }
  657   2              
  658   2              if(in_forks_right == 1) //在三岔右边
  659   2              {
  660   3                
  661   3                temp_ad[4] = ad[4];  // 对 ad 进行处理
  662   3                temp_ad[5] = ad[5];  // 对 ad 进行处理
  663   3                
  664   3                if(ad[4] < 15 && ad[5] < 15)
  665   3                {
  666   4                  temp_ad[4] = ad[4] * 0.7 +  ad[0] * 0.5;
  667   4                  temp_ad[5] = ad[5] * 0.7 +  ad[1] * 0.5;
  668   4                }
  669   3                
  670   3                cha1 =   sqrt(temp_ad[4]) - sqrt(temp_ad[5]) ; //水平电感差
  671   3                
  672   3                cha2 =  sqrt(ad[7]) - sqrt(ad[8]); // 竖直电感差
  673   3                
  674   3                he1 =  (temp_ad[4] + temp_ad[5]); // 水平电感和
  675   3              
  676   3              }
  677   2        
  678   2            }
  679   1            
  680   1            else 
  681   1            {
  682   2            
  683   2      //        if(normal_left == 1)
  684   2      //        {
  685   2      //            
  686   2      //          cha1 = ( (ad[4]) - (ad[5]) ) ; //水平电感差
  687   2      //    
  688   2      //          he1 =   (ad[4] + ad[5]) ; // 水平电感和
  689   2      //    
  690   2      //          cha2 =  ((ad[7]) - (ad[8])); //竖直电感差
  691   2      //        }
  692   2      
  693   2      //        else
  694   2              {
  695   3              
  696   3                if(cir_sancha == 1)
  697   3                {
  698   4                  
  699   4                if(ad[4] < 15 && ad[5] < 15)
  700   4                {
  701   5                  ad[4] = ad[4] * 0.3 +  ad[0] * 0.7;
  702   5                  ad[5] = ad[5] * 0.3 +  ad[1] * 0.7;
  703   5                  cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  704   5                }
  705   4                
  706   4                else if(ad[4] < 35 && ad[5] < 35)
  707   4                {
  708   5                  ad[4] = ad[4] * 0.5 +  ad[0] * 0.5;
  709   5                  ad[5] = ad[5] * 0.5 +  ad[1] * 0.5;
  710   5                  cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  711   5                }
  712   4                
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 12  

  713   4                else
  714   4                {
  715   5                
  716   5                  if(((ad[4] - ad[5]) > 20 && (ad[7] - ad[8]) > 10) || ((ad[4] - ad[5]) < -20 && (ad[7] - ad[8]) < -1
             -0) )
  717   5                  {
  718   6                      if(abs(sqrt(ad[7]) - sqrt(ad[8])) > abs(sqrt(ad[2]) - sqrt(ad[3])))
  719   6                      {
  720   7                          cha2 = sqrt(ad[7]) - sqrt(ad[8]);
  721   7                      }
  722   6                      
  723   6                      else 
  724   6                      {
  725   7                          cha2 = sqrt(ad[2]) - sqrt(ad[3]);
  726   7                      }
  727   6                 }
  728   5                 
  729   5                  else 
  730   5                  {
  731   6                     cha2 = 0;
  732   6                  }
  733   5        
  734   5                }
  735   4                  cha1 = sqrt(ad[4] + 0.3 * ad[0] + ad[9]) - sqrt(ad[5]  + 0.3 * ad[1] + ad[9]) ; //水平电感差
  736   4      
  737   4                  he1 =  ad[4] + ad[5] + ad[9]; // 水平电感和
  738   4                }
  739   3                
  740   3                else 
  741   3                {
  742   4                  if(ad[4] < 15 && ad[5] < 15)
  743   4                  {
  744   5                    temp_ad[4] = ad[4] +  ad[0];
  745   5                    temp_ad[5] = ad[5] +  ad[1];
  746   5                    
  747   5      //              cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  748   5                  }
  749   4                  
  750   4                  else if(ad[4] < 35 && ad[5] < 35)
  751   4                  {
  752   5                    temp_ad[4] = ad[4] +  ad[0] * 0.5;
  753   5                    temp_ad[5] = ad[5] +  ad[1] * 0.5;
  754   5                    
  755   5      //              cha2  = sqrt(ad[2]) - sqrt(ad[3]);
  756   5                  }
  757   4                  else 
  758   4                  {
  759   5                  
  760   5                    temp_ad[4] = ad[4];
  761   5                    temp_ad[5] = ad[5];
  762   5                    
  763   5      //              cha2  = sqrt(ad[7]) - sqrt(ad[8]);
  764   5                  }
  765   4                    
  766   4                    cha1 = sqrt(temp_ad[4]) - sqrt(temp_ad[5]);   
  767   4      
  768   4                    he1 =  temp_ad[4] + temp_ad[5] + ad[7] + ad[8]; // 水平电感和
  769   4                    
  770   4                    if( (sqrt(ad[7]) - sqrt(ad[8])) > (sqrt(ad[4]) - sqrt(ad[5])) )
  771   4                    
  772   4                    cha2 = sqrt(ad[7]) - sqrt(ad[8]);
  773   4                    
  774   4                    else cha2 = sqrt(ad[4]) - sqrt(ad[5]);
  775   4                  
  776   4                  }
  777   3            }
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 13  

  778   2          }
  779   1      
  780   1            s_a = 1;     //水平电感比例
  781   1      
  782   1            if( my_abs(cha2) > 50  )
  783   1            {
  784   2              s_b = 0.45;
  785   2            }
  786   1            
  787   1            if( my_abs(cha2) > 30 )
  788   1            {
  789   2              s_b = 0.35;
  790   2            }
  791   1            
  792   1            else 
  793   1            {
  794   2              s_b = 0.25;  //竖直电感比例
  795   2            }
  796   1            
  797   1            if(in_left) s_b = 0.8; // 左边三岔内
  798   1            
  799   1            s_c = 0.1;  //竖直电感和的比例
  800   1            
  801   1            if(cha2 == 0)
  802   1            {
  803   2               s_error  = 10000 * ( 1 * cha1 + 0.17 * cha2 ) / ( he1);
  804   2            }
  805   1            
  806   1            else 
  807   1            {
  808   2                if(cir_sancha == 1)
  809   2                {
  810   3                  s_error = 8000 * ( 1.25 * cha1 + 0.15 * cha2 ) / ( he1 + my_abs(ad[7] - ad[8]));
  811   3                }
  812   2                
  813   2                else s_error  = 10000 * ( 0.83 * cha1 + 0.165 * cha2 ) / ( he1);
  814   2            } 
  815   1        
  816   1            tuo = w_angle * 0.6 + 0.4 * tuo_l; //一阶惯性滤波
  817   1            
  818   1            if(tuo > 100)
  819   1            {
  820   2              tuo = 100;
  821   2            }
  822   1            
  823   1            if(tuo < -100)
  824   1            {
  825   2              tuo = -100;
  826   2            }
  827   1        
  828   1            if(!s_flag3 )  // 在正常轨道上循迹  
  829   1            {
  830   2                // 修改
  831   2                if(s_error > 500) s_error = 500;
  832   2                
  833   2                else if(s_error < - 500) s_error = -500;
  834   2                
  835   2                else 
  836   2                {
  837   3                  s_error = s_error;
*** WARNING C138 IN LINE 837 OF servo.c: expression with possibly no effect
  838   3                }
  839   2                
  840   2                if(cir_sancha == 1)
  841   2                {
  842   3                  
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 14  

  843   3                  p = 0.11 + log10(abs(s_error) + 1) * 0.028;
  844   3      
  845   3                  d = 0.1 + 1 / ( sqrt(abs(s_error) * 2 ) + 1000);
  846   3                }
  847   2                else 
  848   2                {
  849   3                
  850   3      //            p = s_error * s_error * 0.000002 + 0.11; 76 挺好
  851   3      
  852   3      
  853   3                  // 摆出去 加常数
  854   3      
  855   3                  p = s_error * s_error * 0.00000165 + 0.125;
  856   3                  
  857   3                  if( p >= 0.45)
  858   3                  {
  859   4                    p = 0.45;
  860   4                  }
  861   3      
  862   3      //            d = 0.2; // 76 挺好
  863   3      
  864   3                    d = 0.22;
  865   3                }
  866   2            }
  867   1            
  868   1            if(s_flag3)  //在三岔内部
  869   1            {
  870   2              
  871   2              if(in_forks_left == 1)  //在三岔左边
  872   2              {
  873   3                
  874   3                tuo = w_angle;  
  875   3      
  876   3                p = 0.12;
  877   3                
  878   3                d = 0.19;
  879   3                
  880   3                s_error = 8000 * ( ( cha1 * 0.85 + 0.35 * cha2  ) + s_b * cha2 ) / ( he1 + s_c * my_abs(cha2));
  881   3                
  882   3              }
  883   2              
  884   2              if(in_forks_right == 1)
  885   2              {
  886   3              
  887   3                tuo = w_angle;
  888   3      
  889   3                p = 0.15;
  890   3                
  891   3                d = 0.19;
  892   3                
  893   3                s_error = 8000 * ( ( cha1 * 0.8 + 0.35 * cha2  ) + s_b * cha2 ) / ( he1 + s_c * my_abs(cha2));
  894   3                
  895   3              }
  896   2              
  897   2            }
  898   1            
  899   1      //    在圆环中
  900   1            if(normal_left == 1)
  901   1            { 
  902   2                p = s_error * s_error * 0.00000165 + 0.126;
  903   2                d = 0.2;
  904   2                
  905   2      //          cha1 = sqrt(ad[4] + ad[0] * 0.5) - sqrt(ad[5] + 0.5 * ad[1]);
  906   2      //          
  907   2      //          cha2 = (sqrt(ad[7]) - sqrt(ad[8]));
  908   2      //          
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 15  

  909   2      //          he1 = (ad[4] + ad[5]);
  910   2      //          
  911   2      //          s_error = 8000 * ( cha1 +  cha2 ) / ( he1);
  912   2            }
  913   1        
  914   1            place = p * s_error -  d * (tuo);  //进行pid 转向
  915   1          
  916   1            s_last_error = s_error;
  917   1            
  918   1            if(normal_left == 1)
  919   1            {
  920   2                if(place < (right - mid))
  921   2                {
  922   3                    place = right - mid;
  923   3                }
  924   2                if(place > (left + 10 - mid))
  925   2                {
  926   3                    place = left + 10 - mid;
  927   3                }
  928   2            }
  929   1            
  930   1            else 
  931   1            {
  932   2              
  933   2              if(place < (right - mid))
  934   2              {
  935   3                  place = right - mid;
  936   3              }
  937   2              if(place > (left - mid))
  938   2              {
  939   3                  place = left - mid;
  940   3              }
  941   2            
  942   2            }
  943   1      
  944   1            place = (place + mid);
  945   1            
  946   1            tuo_l = tuo;
  947   1            
  948   1            return (int)place;
  949   1      
  950   1      }
  951          
  952          int circle_pid_Right()
  953          {
  954   1            ps = 2.1;
  955   1        
  956   1            ds = 0.265;
  957   1            
  958   1            cha_s = ad[0] - ( ad[1] * 0.1 + 0.9 * ad[2] );
  959   1            
  960   1            he_s = ad[0] + ad[1];
  961   1            
  962   1            error_s = cha_s * 100  / he_s;
  963   1            
  964   1            place_s = ps * error_s -  ds * (tuo);
  965   1      
  966   1            if(place_s > (right - mid))
  967   1            {
  968   2                place_s = right - mid;
  969   2            }
  970   1            if(place_s < (left - mid))
  971   1            {
  972   2                place_s = left - mid;
  973   2            }
  974   1      
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 16  

  975   1            place_s = (place_s + mid);
  976   1            
  977   1            if(place_s > 690 )
  978   1            {
  979   2              place_s = 690;
  980   2            }
  981   1      
  982   1            return (int)place_s;
  983   1      }
  984          
  985          int circle_pid_Left()
  986          {
  987   1            ps = 1.2;
  988   1        
  989   1            ds = 0.265;
  990   1        
  991   1          // 利用 竖直 电感 引入 圆环
  992   1            
  993   1            error_s = 100 * ( 1.5 * (ad[4] - ad[5]) + 0.5 * ( ad[2] - ad[3]) ) / ( ( ad[4] + ad[5] ) + my_abs( ad[
             -2] - ad[3])); 
  994   1            
  995   1            place_s = ps * error_s -  ds * (tuo);
  996   1      
  997   1            if(place_s > (right - mid))
  998   1            {
  999   2                place_s = right - mid;
 1000   2            }
 1001   1            if(place_s < (left - mid))
 1002   1            {
 1003   2                place_s = left - mid;
 1004   2            }
 1005   1      
 1006   1            place_s = (place_s + mid);
 1007   1                
 1008   1                if( place_s < 710 )
 1009   1                {
 1010   2                  place_s = 710;
 1011   2                }
 1012   1      
 1013   1            return (int)place_s;
 1014   1      
 1015   1             
 1016   1      }
 1017          
 1018          
 1019          
 1020          
 1021          
 1022          
 1023          
 1024          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3222     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       188     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
C251 COMPILER V5.60.0,  servo                                                              07/10/22  19:46:40  PAGE 17  

  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       148     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
